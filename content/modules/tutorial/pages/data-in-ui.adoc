= 5. Working with Data in UI

*WORK IN PROGRESS*

At this stage of development, the application has the Steps and Departments management and the default User management with the added `Onboarding status` attribute. Now you need to link Users with Steps and Departments.

In this chapter, you will do the following:

* Add `department` and `joiningDate` attributes to the `User` entity and show them in UI.
* Create the `UserStep` entity which links a user with an onboarding step.
* Add a collection of `UserStep` entities to the `User` entity and show it on the `User.edit` screen.
* Implement the generation and saving of `UserStep` instances in the `User.edit` screen.

The diagram below shows the entities and attributes addressed in this chapter:

[plantuml]
....
@startuml

entity Step {
    ...
}

entity Department {
    ...
}

entity User {
    ...
    department: Department
    joiningDate
}

entity UserStep {
    id
    user: User
    step: Step
    dueDate
    completedDate
    sortValue
}

User -{ UserStep
UserStep }- Step
Department -{ User

@enduml
....

== Adding Reference Attribute

You've already done a similar task when created the xref:references.adoc#create-reference-attr[HR Manager attribute] of the `Department` entity as a reference to `User`. Now you need to create a link in the opposite direction: a User should have a reference to Department.

[plantuml]
....
@startuml

entity Department {
}

entity User {
    ...
    department: Department
}

Department -{ User

@enduml
....

If your application is running, stop it using the *Stop* button (image:common/suspend.svg[]) in the main toolbar.

Double-click on the `User` entity in *Jmix* tool window and select its last attribute (to add the new attribute to the end).

Click *Add* (image:common/add.svg[]) in the *Attributes* toolbar.

In the *New Attribute* dialog, enter `department` into the *Name* field. Then select:

* *Attribute type*: `ASSOCIATION`
* *Type*: `Department`
* *Cardinality*: *Many to One*

image::data-in-ui/add-attr-1.png[align="center"]

Click *OK*.

Select the new `department` attribute and click the *Add to Screens* (image:common/add-attribute-to-screens.svg[]) button in the *Attributes* toolbar:

image::data-in-ui/add-attr-2.png[align="center", width="445"]

The appeared dialog window will show `User.edit` and `User.browse` screens. Select both screens and click *OK*.

Studio will add the `department` attribute to the table component of the `User.browse` screen and to the form component of the `User.edit` screen.

You may also notice the following code added by Studio automatically to `User.browse`:

[source,xml]
----
<data readOnly="true">
    <collection id="usersDc"
                class="com.company.onboarding.entity.User">
        <fetchPlan extends="_base">
            <property name="department" fetchPlan="_base"/> <!-- added -->
        </fetchPlan>
----

And to `User.edit`:

[source,xml]
----
<data>
    <instance id="userDc"
              class="com.company.onboarding.entity.User">
        <fetchPlan extends="_base">
            <property name="department" fetchPlan="_base"/> <!-- added -->
        </fetchPlan>
----

With this code, the referenced Department will be loaded together with the User in the same database query.

TIP: The screens would work without including `department` in the fetch plans due to the _lazy loading_ of references. But in this case, the references would be loaded by separate requests to the database. Lazy loading can affect performance of the browse screen, because then it loads a list of Users with a first request, and after that, executes separate requests for loading a Department of each User in the list (N+1 query problem).

Let's run the application and see the new attribute in action.

Click the *Debug* button (image:common/start-debugger.svg[]) in the main toolbar.

Studio will generate a Liquibase changelog for adding the `DEPARTMENT_ID` column to the `USER_` table, creating a foreign key constraint and an index. Confirm the changelog.

Studio will execute the changelog and start the application.

Open `++http://localhost:8080++` in your web browser and log in to the application with `admin` / `admin` credentials.

Click on the *Users* item in the *Application* menu. You will see the *Department* column in the `User.browse` screen and *Department* picker field in `User.edit`:

image::data-in-ui/add-attr-3.png[align="center", width="507"]

== Using Dropdown for Selecting Reference

By default, Studio generates the `entityPicker` component for selecting references. You can see it in the `User.edit` screen. Open `user-edit.xml` and switch to XML editor using the button in the top panel:

image::data-in-ui/dropdown-1.png[align="center", width="689"]

Find the `entityPicker` component inside the `form`:

[source,xml]
----
<layout ...>
    <form id="form" dataContainer="userDc">
        <column width="350px">
            ...
            <entityPicker id="departmentField" property="department"/>
        </column>
    </form>
----

This component allows you to select a related entity from a lookup screen with filtering, sorting and paging. But when the expected number of records is relatively small (say, less than 1000), it's more convenient to select references from a simple dropdown list.

Let's change the `User.edit` screen and use the `entityComboBox` component for selecting a Department.

Change the XML element of the component to `entityComboBox`:

[source,xml]
----
<entityComboBox id="departmentField" property="department"/>
----

Switch to the running application and reopen the User editor screen.

You will see that the *Department* field is now a dropdown, but its list is empty, even if you have created some Departments.

image::data-in-ui/dropdown-2.png[align="center", width="506"]

=== Creating Options Data Container

Let's provide a list of options to the `entityComboBox` component displaying the reference to Department. The list should contain all Departments ordered by name.

Select `Data components` section in the *Component Palette* tool window, drag the `Collection` item and drop it onto the `data` element in the *Component Hierarchy*. In the *Data Container Properties Editor* window, select `Department` in the *Entity* field and click *OK*:

image::data-in-ui/options-container-1.gif[align="center"]

The new `collection` element with `departmentsDc` id will be created under the `data` element in *Component Hierarchy* and in XML:

[source,xml]
----
<data>
    ...
    <collection id="departmentsDc" class="com.company.onboarding.entity.Department">
        <fetchPlan extends="_base"/>
        <loader id="departmentsDl">
            <query>
                <![CDATA[select e from Department e]]>
            </query>
        </loader>
    </collection>
</data>
----

This element defines a _collection data container_ and a _loader_ for it. The data container will contain a list of Department entities loaded by the loader with the specified query.

You can edit the query right in the XML or use the JPQL designer opened by  the link in the `query` attribute shown in *Component Inspector* tool window:

image::data-in-ui/options-container-2.png[align="center"]

In the *JPQL Query Designer* window, switch to the *ORDER* tab and add the `name` attribute to the list:

image::data-in-ui/options-container-3.png[align="center"]

Click *OK*.

The resulting query in XML will look like this:

[source,xml]
----
<data>
    ...
    <collection id="departmentsDc" class="com.company.onboarding.entity.Department">
        <fetchPlan extends="_base"/>
        <loader id="departmentsDl">
            <query>
                <![CDATA[select e from Department e
                order by e.name asc]]>
            </query>
        </loader>
    </collection>
</data>
----

Now you need to link the `entityComboBox` component with the `departmentsDc` collection container.

Select `departmentField` in *Component Hierarchy* and select `departmentsDc` for the `optionsContainer` attribute in *Component Inspector*:

image::data-in-ui/options-container-4.png[align="center"]

Switch to the running application and reopen the User editor screen.

You will see that the *Department* dropdown now has a list of options:

image::data-in-ui/dropdown-3.png[align="center", width="496"]

TIP: The `entityComboBox` component allows you to filter options by entering text into the field. But keep in mind that filtering is performed in the server memory, all options are loaded from the database at once.

== Creating UserStep Entity

In this section, you will create the `UserStep` entity which represents onboarding Steps for a particular User:

[plantuml]
....
@startuml

entity Step {
    ...
}

entity User {
    ...
}

entity UserStep {
    id
    user: User
    step: Step
    dueDate
    completedDate
    sortValue
}

User -{ UserStep
UserStep }- Step

@enduml
....

If your application is running, stop it using the *Stop* button (image:common/suspend.svg[]) in the main toolbar.

In the *Jmix* tool window, click *New* (image:common/add.svg[]) -> *JPA Entity* and create `UserStep` entity with *Versioned* trait as you did xref:references.adoc#create-entity[before].

Add the following attributes to the new entity:

|===
|Name |Attribute type |Type |Cardinality  |Mandatory

|user
|ASSOCIATION
|User
|Many to One
|true

|step
|ASSOCIATION
|Step
|Many to One
|true

|dueDate
|DATATYPE
|LocalDate
|-
|true

|completedDate
|DATATYPE
|LocalDate
|-
|false

|sortValue
|DATATYPE
|Integer
|-
|true

|===

The final state of the entity designer should look as below:

image::data-in-ui/create-user-step-1.png[align="center"]

== Adding Composition Attribute

Consider the relationship between `User` and `UserStep` entities. `UserStep` instances exist only in the context of a particular `User` instance (owned by it). A `UserStep` instance cannot change its owner - it just doesn't make any sense. Also, there are no links to `UserStep` from other data model objects, they are completely encapsulated in a User context.

In Jmix, such a relationship is called _composition_: the User is composed of a collection of UserSteps, among other attributes.

TIP: Composition in Jmix implements the Aggregate pattern of Domain-Driven Design.

It's often convenient to create an attribute that contains the collection of composition items in the owning entity.

Let's create the `steps` attribute in the `User` entity:

[plantuml]
....
@startuml

entity User {
    ...
    steps: List<UserStep>
}

entity UserStep {
    ...
    user: User
}

User -{ UserStep

@enduml
....

If your application is running, stop it using the *Stop* button (image:common/suspend.svg[]) in the main toolbar.

Click *Add* (image:common/add.svg[]) in the *Attributes* toolbar of the `User` entity designer. In the *New Attribute* dialog, enter `steps` into the *Name* field. Then select:

* *Attribute type*: `COMPOSITION`
* *Type*: `UserStep`
* *Cardinality*: *One to Many*

image::data-in-ui/composition-1.png[align="center"]

Notice that `user` is selected automatically in the *Mapped by* field. It's the attribute of the `UserStep` entity mapped to a database column which maintains the relationship between UserSteps and Users (the foreign key).

Click *OK*.

UserSteps should be displayed in the User edit screen, so select the new `steps` attribute and click the *Add to Screens* (image:common/add-attribute-to-screens.svg[]) button in the *Attributes* toolbar. Select `User.edit` screen and click *OK*.

Studio will modify `user-edit.xml` as shown below:

[source,xml]
----
<data>
    <instance id="userDc"
              class="com.company.onboarding.entity.User">
        <fetchPlan extends="_base">
            <property name="department" fetchPlan="_base"/>
            <property name="steps" fetchPlan="_base"/> <!--1-->
        </fetchPlan>
        <loader/>
        <collection id="stepsDc" property="steps"/> <!--2-->
    </instance>
    ...
<layout ...>
    <form id="form" dataContainer="userDc">
        ...
    </form>
    <groupBox id="stepsBox" ...>
        <table id="stepsTable" dataContainer="stepsDc" ...> <!--3-->
            <actions>
                <action id="create" type="create"/>
                <action id="edit" type="edit"/>
                <action id="remove" type="remove"/>
            </actions>
            <columns>
                <column id="version"/>
                <column id="dueDate"/>
                <column id="completedDate"/>
                <column id="sortValue"/>
            </columns>
            <buttonsPanel>
                <button action="stepsTable.create"/>
                <button action="stepsTable.edit"/>
                <button action="stepsTable.remove"/>
            </buttonsPanel>
        </table>
    </groupBox>
----
<1> Attribute `steps` of the fetch plan ensures the collection of UserSteps is loaded eagerly together with User.
<2> The nested `stepsDc` collection data container enables binding of visual components to the `steps` collection attribute.
<3> The `table` component wrapped in `groupBox` displays data from the linked `stepsDc` collection container.

Letâ€™s run the application and see these changes in action.

Click the *Debug* button (image:common/start-debugger.svg[]) in the main toolbar.

Studio will generate a Liquibase changelog for creating the `USER_STEP` table, foreign key constraints and indexes for references to `USER_` and `STEP`. Confirm the changelog.

Studio will execute the changelog and start the application.

Open `++http://localhost:8080++` in your web browser and log in to the application with `admin` / `admin` credentials.

Open a user for editing. You will see the *Steps* table displaying the `UserStep` entity:

image::data-in-ui/composition-2.png[align="center"]

If you click *Create* in the *Steps* table, you will get an exception saying that `Screen 'UserStep.edit' is not defined`. This is true - you didn't create an edit screen for the `UserStep` entity. But you don't actually need it, because `UserStep` instances should be generated from the predefined `Step` instances for the particular `User`.

== Generating UserSteps for User

In this section, you will implement the generation and showing of `UserStep` instances for the edited `User`.

=== Adding JoiningDate Attribute

First, let's add the `joiningDate` attribute to the `User` entity:

[plantuml]
....
@startuml

entity User {
    ...
    joiningDate
}

@enduml
....

It will be used to calculate the `dueDate` attribute of the generated `UserStep` entity: `UserStep.dueDate = User.joiningDate + Step.duration`.

If your application is running, stop it using the *Stop* button (image:common/suspend.svg[]) in the main toolbar.

Click *Add* (image:common/add.svg[]) in the *Attributes* toolbar of the `User` entity designer. In the *New Attribute* dialog, enter `joiningDate` into the *Name* field and select `LocalDate` in the *Type* field:

image::data-in-ui/joining-date-1.png[align="center"]

Click *OK*.

Select the newly created `joiningDate` attribute and click the *Add to Screens* (image:common/add-attribute-to-screens.svg[]) button in the *Attributes* toolbar. Select both `User.edit` and `User.browse` screens in the appeared dialog and click *OK*.

Click the *Debug* button (image:common/start-debugger.svg[]) in the main toolbar.

Studio will generate a Liquibase changelog for adding the `JOINING_DATE` column to the `USER_` table. Confirm the changelog.

Studio will execute the changelog and start the application. Open `++http://localhost:8080++` in your web browser, log in to the application and check that the new attribute is shown in the User browse edit screens.

=== Adding Custom Button

Now you need to remove the standard actions and buttons for managing UserSteps and add a button for starting a custom logic of creating entities.

Open `user-edit.xml` and remove the `actions` element and all `button` elements from `table`:

[source,xml]
----
<table id="stepsTable" dataContainer="stepsDc" width="100%" height="200px">
    <columns>
        <column id="version"/>
        <column id="dueDate"/>
        <column id="completedDate"/>
        <column id="sortValue"/>
    </columns>
    <buttonsPanel>
    </buttonsPanel>
</table>
----

Then drag and drop the `Button` component from *Component Palette* onto the `buttonsPanel` element in *Component Hierarchy*. Then select the created `button` element and set its `id` to `generateButton` and `caption` to `Generate` in *Component Inspector*. After that, switch to the *Handlers* tab and create a `ClickEvent` handler method:

image::data-in-ui/button-1.gif[]

Press *Ctrl/Cmd+S* and switch to the running application. Reopen the User edit screen and check that the *Generate* button is shown instead of the standard CRUD buttons:

image:data-in-ui/button-2.png[align="center"]

=== Creating and Saving UserStep Instances

Let's implement the logic of generating `UserStep` instances.

Add the following fields to the `UserEdit` controller:

[source,java]
----
public class UserEdit extends StandardEditor<User> {

    @Autowired
    private DataManager dataManager;

    @Autowired
    private DataContext dataContext;

    @Autowired
    private CollectionPropertyContainer<UserStep> stepsDc;
----

[TIP]
====
You can inject screen components and Spring beans using the *Inject* button in the actions panel:

image::data-in-ui/inject-1.gif[]
====

Add the logic of creating and saving `UserStep` objects to the `generateButton` handler method:

[source,java]
----
@Subscribe("generateButton")
public void onGenerateButtonClick(Button.ClickEvent event) {
    User user = getEditedEntity(); // <1>

    if (user.getJoiningDate() == null) { // <2>
        notifications.create()
                .withCaption("Cannot generate steps for user without 'Joining date'")
                .show();
        return;
    }

    List<Step> steps = dataManager.load(Step.class)
            .query("select s from Step s order by s.sortValue asc")
            .list(); // <3>

    for (Step step : steps) {
        if (stepsDc.getItems().stream().noneMatch(userStep ->
                    userStep.getStep().equals(step))) { // <4>
            UserStep userStep = dataContext.create(UserStep.class); // <5>
            userStep.setUser(user);
            userStep.setStep(step);
            userStep.setDueDate(user.getJoiningDate().plusDays(step.getDuration()));
            userStep.setSortValue(step.getSortValue());
            stepsDc.getMutableItems().add(userStep); // <6>
        }
    }
}
----
<1> Use `getEditedEntity()` method of the base `StandardEditor` class to get the `User` being edited.
<2> If `joiningDate` attribute is not set, show a message and quit.
<3> Load the list of registered Steps.
<4> Skip the Step if it's already in the `stepsDc` collection container.
<5> Create new `UserStep` instance using `DataContext.create()` method.
<6> Add the new `UserStep` instance to the `stepsDc` collection container to show it in the UI.

NOTE: When you create an entity instance through the `DataContext` object, the instance becomes managed by `DataContext` and is saved automatically when the screen is committed, that is when you click *OK* button of the screen.

Press *Ctrl/Cmd+S* and switch to the running application. Reopen the User edit screen and check that when you click the *Generate* button, a few records corresponding to the onboarding Steps are created.
